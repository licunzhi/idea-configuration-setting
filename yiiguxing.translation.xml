<application>
  <component name="AppStorage">
    <histories>
      <item value="评估月份" />
      <item value="客流趋势" />
      <item value="过时" />
      <item value="Dual Pivot Quick sort" />
      <item value="Dual Pivot Quicksort" />
      <item value="基本数据类型采用的是快速排序法Dual Pivot Quicksort" />
      <item value="多线程" />
      <item value="单线程" />
      <item value="请求前缀" />
      <item value="单位时间发送次数测试" />
      <item value="单位时间" />
      <item value="Reports unstable API (elements annotated with one of annotations from list) usages." />
      <item value="设置分辨率" />
      <item value="词汇分析器 设置分析参数" />
      <item value="中文解析" />
      <item value="海王" />
      <item value="Duplicate" />
      <item value="See documentation in docs/topics/spiders.rst" />
      <item value="Request Body" />
      <item value="equivalent" />
      <item value="granting" />
      <item value="&lt;p&gt;A {@code ReentrantLock} is &lt;em&gt;owned&lt;/em&gt; by the thread last&#10; * successfully locking, but not yet unlocking it. A thread invoking&#10; * {@code lock} will return, successfully acquiring the lock, when&#10; * the lock is not owned by another thread. The method will return&#10; * immediately if the current thread already owns the lock. This can&#10; * be checked using methods {@link #isHeldByCurrentThread}, and {@link&#10; * #getHoldCount}." />
      <item value="A reentrant mutual exclusion {@link Lock} with the same basic&#10; * behavior and semantics as the implicit monitor lock accessed using&#10; * {@code synchronized} methods and statements, but with extended&#10; * capabilities." />
      <item value="March over the array once, left to right, finding natural runs,&#10;         * extending short natural runs to minRun elements, and merging runs&#10;         * to maintain stack invariant." />
      <item value="Arrays of size 0 and 1 are always sorted" />
      <item value="/**&#10;     * Sorts the specified portion of the specified array using a binary&#10;     * insertion sort.  This is the best method for sorting small numbers&#10;     * of elements.  It requires O(n log n) compares, but O(n^2) data&#10;     * movement (worst case).&#10;     *&#10;     * If the initial part of the specified range is already sorted,&#10;     * this method can take advantage of it: the method assumes that the&#10;     * elements from index {@code lo}, inclusive, to {@code start},&#10;     * exclusive are already sorted.&#10;     *&#10;     * @param a the array in which a range is to be sorted&#10;     * @param lo the index of the first element in the range to be sorted&#10;     * @param hi the index after the last element in the range to be sorted&#10;     * @param start the index of the first element in the range that is&#10;     *        not already known to be sorted ({@code lo &lt;= start &lt;= hi})&#10;     * @param c comparator to used for the sort&#10;     */&#10;    @SuppressWarnings(&quot;fallthrough&quot;)" />
      <item value="If array is small, do a &quot;mini-TimSort&quot; with no merges" />
      <item value="Merge sorted halves (now in src) into dest" />
      <item value="optimization" />
      <item value="Insertion sort on smallest arrays" />
      <item value="To be removed in a future release." />
      <item value="used in preference to mergesort." />
      <item value="Tuning parameter: list size at or below which insertion sort will be" />
      <item value="legacy Merge Sort" />
      <item value="legacy" />
      <item value="Navigable" />
      <item value="Sorted Map" />
      <item value="comparisons" />
      <item value="consistent" />
      <item value="analogue" />
      <item value="segment" />
      <item value="creation" />
      <item value="evict" />
      <item value="/**&#10;     * The bin count threshold for untreeifying a (split) bin during a&#10;     * resize operation. Should be less than TREEIFY_THRESHOLD, and at&#10;     * most 6 to mesh with shrinkage detection under removal.&#10;     */" />
      <item value="The bin count threshold for using a tree rather than list for a&#10;     * bin.  Bins are converted to trees when adding an element to a&#10;     * bin with at least this many nodes. The value must be greater&#10;     * than 2 and should be at least 8 to mesh with assumptions in&#10;     * tree removal about conversion back to plain bins upon&#10;     * shrinkage." />
      <item value="Tree bins (i.e., bins whose elements are all TreeNodes) are      * ordered primarily by hashCode, but in the case of ties, if two      * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,      * type then their compareTo method is used for ordering. (We      * conservatively check generic types via reflection to validate      * this -- see method comparableClassFor).  The added complexity      * of tree bins is worthwhile in providing worst-case O(log n)      * operations when keys either have distinct hashes or are      * orderable, Thus, performance degrades gracefully under      * accidental or malicious usages in which hashCode() methods      * return values that are poorly distributed, as well as those in      * which many keys share a hashCode, so long as they are also      * Comparable. (If neither of these apply, we may waste about a      * factor of two in time and space compared to taking no      * precautions. But the only known cases stem from poor user      * programming practices that are already so slow that this makes      * little difference.)" />
      <item value="Tree bins (i.e., bins whose elements are all TreeNodes) are&#10;     * ordered primarily by hashCode, but in the case of ties, if two&#10;     * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,&#10;     * type then their compareTo method is used for ordering. (We&#10;     * conservatively check generic types via reflection to validate&#10;     * this -- see method comparableClassFor).  The added complexity&#10;     * of tree bins is worthwhile in providing worst-case O(log n)&#10;     * operations when keys either have distinct hashes or are&#10;     * orderable, Thus, performance degrades gracefully under&#10;     * accidental or malicious usages in which hashCode() methods&#10;     * return values that are poorly distributed, as well as those in&#10;     * which many keys share a hashCode, so long as they are also&#10;     * Comparable. (If neither of these apply, we may waste about a&#10;     * factor of two in time and space compared to taking no&#10;     * precautions. But the only known cases stem from poor user&#10;     * programming practices that are already so slow that this makes&#10;     * little difference.)" />
      <item value="This map usually acts as a binned (bucketed) hash table, but      * when bins get too large, they are transformed into bins of      * TreeNodes, each structured similarly to those in      * java.util.TreeMap. Most methods try to use normal bins, but      * relay to TreeNode methods when applicable (simply by checking      * instanceof a node).  Bins of TreeNodes may be traversed and      * used like any others, but additionally support faster lookup      * when overpopulated. However, since the vast majority of bins in      * normal use are not overpopulated, checking for existence of      * tree bins may be delayed in the course of table methods." />
      <item value="This map usually acts as a binned (bucketed) hash table, but&#10;     * when bins get too large, they are transformed into bins of&#10;     * TreeNodes, each structured similarly to those in&#10;     * java.util.TreeMap. Most methods try to use normal bins, but&#10;     * relay to TreeNode methods when applicable (simply by checking&#10;     * instanceof a node).  Bins of TreeNodes may be traversed and&#10;     * used like any others, but additionally support faster lookup&#10;     * when overpopulated. However, since the vast majority of bins in&#10;     * normal use are not overpopulated, checking for existence of&#10;     * tree bins may be delayed in the course of table methods." />
      <item value="overpopulated" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="52" />
        <entry key="ENGLISH" value="52" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="primaryFontFamily" value="Consolas" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="primaryLanguage" value="ENGLISH" />
      </youdao-translate>
    </option>
  </component>
</application>