<application>
  <component name="AppStorage">
    <histories>
      <item value="街道" />
      <item value="stree" />
      <item value="区县" />
      <item value="地市" />
      <item value="区县编码" />
      <item value="移动游客分析" />
      <item value="on" />
      <item value="备份" />
      <item value="BACKPACK" />
      <item value="定制" />
      <item value="x" />
      <item value="故障" />
      <item value="水波" />
      <item value="立方体" />
      <item value="掌上图书" />
      <item value="图书馆" />
      <item value="场馆" />
      <item value="收藏" />
      <item value="tada" />
      <item value="rubberband" />
      <item value="infinite" />
      <item value="Bounce" />
      <item value="bounce" />
      <item value="小仙女" />
      <item value="小祖宗" />
      <item value="MAX CAHE COUNT" />
      <item value="max cahe count" />
      <item value="审核" />
      <item value="EVENT ID" />
      <item value="驻留时长" />
      <item value="人口类型" />
      <item value="Simple stop watch, allowing for timing of a number of tasks, exposing total running time and running time for each named task. Conceals use of System.currentTimeMillis(), improving the readability of application code and reducing the likelihood of calculation errors. Note that this object is not designed to be thread-safe and does not use synchronization." />
      <item value="Simple stop watch, allowing for timing of a number of tasks, exposing total running time and running time for each named task.&#10;Conceals use of System.currentTimeMillis(), improving the readability of application code and reducing the likelihood of calculation errors.&#10;Note that this object is not designed to be thread-safe and does not use synchronization." />
      <item value="deduce Main Application Class" />
      <item value="Determine whether the given {@code Class} is a Kotlin type" />
      <item value="Determine whether Kotlin reflection is present." />
      <item value="Determine whether Kotlin is present in general." />
      <item value="A common delegate for detecting Kotlin's presence and for identifying Kotlin types." />
      <item value="delegate" />
      <item value="instantiate Class" />
      <item value="An enumeration of possible types of web application." />
      <item value="Configures component scanning directives for use with @{@link Configuration} classes.&#10; * Provides support parallel with Spring XML's {@code &lt;context:component-scan&gt;} element.&#10; *&#10; * &lt;p&gt;Either {@link #basePackageClasses} or {@link #basePackages} (or its alias&#10; * {@link #value}) may be specified to define specific packages to scan. If specific&#10; * packages are not defined, scanning will occur from the package of the&#10; * class that declares this annotation.&#10; *&#10; * &lt;p&gt;Note that the {@code &lt;context:component-scan&gt;} element has an&#10; * {@code annotation-config} attribute; however, this annotation does not. This is because&#10; * in almost all cases when using {@code @ComponentScan}, default annotation config&#10; * processing (e.g. processing {@code @Autowired} and friends) is assumed. Furthermore,&#10; * when using {@link AnnotationConfigApplicationContext}, annotation config processors are&#10; * always registered, meaning that any attempt to disable them at the&#10; * {@code @ComponentScan} level would be ignored." />
      <item value="Container annotation that aggregates several ComponentScan annotations. Can be used natively, declaring several nested ComponentScan annotations. Can also be used in conjunction with Java 8's support for repeatable annotations, where ComponentScan can simply be declared several times on the same method, implicitly generating this container annotation." />
      <item value="Container annotation that aggregates several ComponentScan annotations.&#10;Can be used natively, declaring several nested ComponentScan annotations. Can also be used in conjunction with Java 8's support for repeatable annotations, where ComponentScan can simply be declared several times on the same method, implicitly generating this container annotation." />
      <item value="Indicates one or more @Configuration classes to import. Provides functionality equivalent to the &lt;import/&gt; element in Spring XML. Allows for importing @Configuration classes, ImportSelector and ImportBeanDefinitionRegistrar implementations, as well as regular component classes (as of 4.2; analogous to AnnotationConfigApplicationContext.register). @Bean definitions declared in imported @Configuration classes should be accessed by using @Autowired injection. Either the bean itself can be autowired, or the configuration class instance declaring the bean can be autowired. The latter approach allows for explicit, IDE-friendly navigation between @Configuration class methods. May be declared at the class level or as a meta-annotation. If XML or other non-@Configuration bean definition resources need to be imported, use the @ImportResource annotation instead." />
      <item value="Indicates one or more @Configuration classes to import.&#10;Provides functionality equivalent to the &lt;import/&gt; element in Spring XML. Allows for importing @Configuration classes, ImportSelector and ImportBeanDefinitionRegistrar implementations, as well as regular component classes (as of 4.2; analogous to AnnotationConfigApplicationContext.register).&#10;@Bean definitions declared in imported @Configuration classes should be accessed by using @Autowired injection. Either the bean itself can be autowired, or the configuration class instance declaring the bean can be autowired. The latter approach allows for explicit, IDE-friendly navigation between @Configuration class methods.&#10;May be declared at the class level or as a meta-annotation.&#10;If XML or other non-@Configuration bean definition resources need to be imported, use the @ImportResource annotation instead." />
      <item value="Auto-configuration tries to be as intelligent as possible and will back-away as you define more of your own configuration. You can always manually exclude() any configuration that you never want to apply (use excludeName() if you don't have access to them). You can also exclude them via the spring.autoconfigure.exclude property. Auto-configuration is always applied after user-defined beans have been registered. The package of the class that is annotated with @EnableAutoConfiguration, usually via @SpringBootApplication, has specific significance and is often used as a 'default'. For example, it will be used when scanning for @Entity classes. It is generally recommended that you place @EnableAutoConfiguration (if you're not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched. Auto-configuration classes are regular Spring Configuration beans. They are located using the SpringFactoriesLoader mechanism (keyed against this class). Generally auto-configuration beans are @Conditional beans (most often using @ConditionalOnClass and @ConditionalOnMissingBean annotations)." />
      <item value="Auto-configuration tries to be as intelligent as possible and will back-away as you define more of your own configuration. You can always manually exclude() any configuration that you never want to apply (use excludeName() if you don't have access to them). You can also exclude them via the spring.autoconfigure.exclude property. Auto-configuration is always applied after user-defined beans have been registered.&#10;The package of the class that is annotated with @EnableAutoConfiguration, usually via @SpringBootApplication, has specific significance and is often used as a 'default'. For example, it will be used when scanning for @Entity classes. It is generally recommended that you place @EnableAutoConfiguration (if you're not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched.&#10;Auto-configuration classes are regular Spring Configuration beans. They are located using the SpringFactoriesLoader mechanism (keyed against this class). Generally auto-configuration beans are @Conditional beans (most often using @ConditionalOnClass and @ConditionalOnMissingBean annotations)." />
      <item value="Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined. For example, if you have tomcat-embedded.jar on your classpath you are likely to want a TomcatServletWebServerFactory (unless you have defined your own ServletWebServerFactory bean). When using SpringBootApplication, the auto-configuration of the context is automatically enabled and adding this annotation has therefore no additional effect." />
      <item value="Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined. For example, if you have tomcat-embedded.jar on your classpath you are likely to want a TomcatServletWebServerFactory (unless you have defined your own ServletWebServerFactory bean).&#10;When using SpringBootApplication, the auto-configuration of the context is automatically enabled and adding this annotation has therefore no additional effect." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="159" />
        <entry key="ENGLISH" value="159" />
        <entry key="LITHUANIAN" value="2" />
        <entry key="BENGALI" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="HUNGARIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="primaryFontFamily" value="Consolas" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="primaryLanguage" value="ENGLISH" />
      </youdao-translate>
    </option>
  </component>
</application>