<application>
  <component name="AppStorage">
    <histories>
      <item value="abbreviation" />
      <item value="子账号管理" />
      <item value="待发布" />
      <item value="排除" />
      <item value="查询条件" />
      <item value="上映" />
      <item value="order by stat_time asc" />
      <item value="gamma Output" />
      <item value="antialias" />
      <item value="_antialias" />
      <item value="Loader for Basis Universal GPU Texture Codec.&#10; *&#10; * Basis Universal is a &quot;supercompressed&quot; GPU texture and texture video&#10; * compression system that outputs a highly compressed intermediate file format&#10; * (.basis) that can be quickly transcoded to a wide variety of GPU texture&#10; * compression formats.&#10; *&#10; * This loader parallelizes the transcoding process across a configurable number&#10; * of web workers, before transferring the transcoded compressed texture back&#10; * to the main thread." />
      <item value="device Pixel Ratio" />
      <item value="季度" />
      <item value="Mesh Lambert Material" />
      <item value="anisotropy" />
      <item value="poles" />
      <item value="fog" />
      <item value="select stat_date,src_type,src_code,cust_cnt from TUR_F_REG_CUSTSRC_DAY TFRCD WHERE     TFRCD.REG_ID=:REGID AND TFRCD.SRC_TYPE=0 AND TFRCD.SRC_CODE='0'    AND TFRCD.STAT_DATE&gt;=:startTime AND TFRCD.STAT_DATE&lt;=:endTime" />
      <item value="select stat_date,src_type,src_code,cust_cnt from TUR_F_REG_CUSTSRC_DAY TFRCD WHERE&#10;    TFRCD.REG_ID=:REGID AND TFRCD.SRC_TYPE=0 AND TFRCD.SRC_CODE='0'&#10;   AND TFRCD.STAT_DATE&gt;=:startTime AND TFRCD.STAT_DATE&lt;=:endTime" />
      <item value="出行" />
      <item value="范围" />
      <item value="省内客流" />
      <item value="reporttype" />
      <item value="Distribution" />
      <item value="分布" />
      <item value="time TYPE" />
      <item value="市县分析" />
      <item value="TUR FAC REG CUSTCNT DAY" />
      <item value="traverse Shape" />
      <item value="number" />
      <item value="wm concat" />
      <item value="hot spot click" />
      <item value="hotspotclick" />
      <item value="t.insight task status" />
      <item value="Variable map implicitly declared" />
      <item value="load Heat Map" />
      <item value="拦截器" />
      <item value="to classify a filter by type. Standard types in Zuul are &quot;pre&quot; for pre-routing filtering,      * &quot;route&quot; for routing to an origin, &quot;post&quot; for post-routing filters, &quot;error&quot; for error handling.      * We also support a &quot;static&quot; type for static responses see  StaticResponseFilter.      * Any filterType made be created or added and run by calling FilterProcessor.runFilters(type)" />
      <item value="to classify a filter by type. Standard types in Zuul are &quot;pre&quot; for pre-routing filtering,&#10;     * &quot;route&quot; for routing to an origin, &quot;post&quot; for post-routing filters, &quot;error&quot; for error handling.&#10;     * We also support a &quot;static&quot; type for static responses see  StaticResponseFilter.&#10;     * Any filterType made be created or added and run by calling FilterProcessor.runFilters(type)" />
      <item value="Object to represent a SQL parameter value, including parameter metadata such as the SQL type and the scale for numeric values. Designed for use with JdbcTemplate's operations that take an array of argument values: Each such argument value may be a SqlParameterValue, indicating the SQL type (and optionally the scale) instead of letting the template guess a default type. Note that this only applies to the operations with a 'plain' argument array, not to the overloaded variants with an explicit type array." />
      <item value="Object to represent a SQL parameter value, including parameter metadata such as the SQL type and the scale for numeric values.&#10;Designed for use with JdbcTemplate's operations that take an array of argument values: Each such argument value may be a SqlParameterValue, indicating the SQL type (and optionally the scale) instead of letting the template guess a default type. Note that this only applies to the operations with a 'plain' argument array, not to the overloaded variants with an explicit type array." />
      <item value="Parse the SQL statement and locate any placeholders or named parameters. Named&#10;&#9; * parameters are substituted for a JDBC placeholder, and any select list is expanded&#10;&#9; * to the required number of placeholders. Select lists may contain an array of&#10;&#9; * objects, and in that case the placeholders will be grouped and enclosed with&#10;&#9; * parentheses. This allows for the use of &quot;expression lists&quot; in the SQL statement&#10;&#9; * like: &lt;br /&gt;&lt;br /&gt;&#10;&#9; * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}&#10;&#9; * &lt;p&gt;The parameter values passed in are used to determine the number of placeholders to&#10;&#9; * be used for a select list. Select lists should be limited to 100 or fewer elements.&#10;&#9; * A larger number of elements is not guaranteed to be supported by the database and&#10;&#9; * is strictly vendor-dependent.&#10;&#9; * @param parsedSql the parsed representation of the SQL statement&#10;&#9; * @param paramSource the source for named parameters&#10;&#9; * @return the SQL statement with substituted parameters&#10;&#9; * @see #parseSqlStatement" />
      <item value="/** &#9; * Parse the SQL statement and locate any placeholders or named parameters. Named &#9; * parameters are substituted for a JDBC placeholder, and any select list is expanded &#9; * to the required number of placeholders. Select lists may contain an array of &#9; * objects, and in that case the placeholders will be grouped and enclosed with &#9; * parentheses. This allows for the use of &quot;expression lists&quot; in the SQL statement &#9; * like: &lt;br /&gt;&lt;br /&gt; &#9; * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))} &#9; * &lt;p&gt;The parameter values passed in are used to determine the number of placeholders to &#9; * be used for a select list. Select lists should be limited to 100 or fewer elements. &#9; * A larger number of elements is not guaranteed to be supported by the database and &#9; * is strictly vendor-dependent. &#9; * @param parsedSql the parsed representation of the SQL statement &#9; * @param paramSource the source for named parameters &#9; * @return the SQL statement with substituted parameters &#9; * @see #parseSqlStatement" />
      <item value="/**&#10;&#9; * Parse the SQL statement and locate any placeholders or named parameters. Named&#10;&#9; * parameters are substituted for a JDBC placeholder, and any select list is expanded&#10;&#9; * to the required number of placeholders. Select lists may contain an array of&#10;&#9; * objects, and in that case the placeholders will be grouped and enclosed with&#10;&#9; * parentheses. This allows for the use of &quot;expression lists&quot; in the SQL statement&#10;&#9; * like: &lt;br /&gt;&lt;br /&gt;&#10;&#9; * {@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}&#10;&#9; * &lt;p&gt;The parameter values passed in are used to determine the number of placeholders to&#10;&#9; * be used for a select list. Select lists should be limited to 100 or fewer elements.&#10;&#9; * A larger number of elements is not guaranteed to be supported by the database and&#10;&#9; * is strictly vendor-dependent.&#10;&#9; * @param parsedSql the parsed representation of the SQL statement&#10;&#9; * @param paramSource the source for named parameters&#10;&#9; * @return the SQL statement with substituted parameters&#10;&#9; * @see #parseSqlStatement" />
      <item value="{@link RowMapper} implementation that creates a {@code java.util.Map}  * for each row, representing all columns as key-value pairs: one  * entry for each column, with the column name as key.  *  * &lt;p&gt;The Map implementation to use and the key to use for each column  * in the column Map can be customized through overriding  * {@link #createColumnMap} and {@link #getColumnKey}, respectively.  *  * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; By default, ColumnMapRowMapper will try to build a linked Map  * with case-insensitive keys, to preserve column order as well as allow any  * casing to be used for column names. This requires Commons Collections on the  * classpath (which will be autodetected). Else, the fallback is a standard linked  * HashMap, which will still preserve column order but requires the application  * to specify the column names in the same casing as exposed by the driver." />
      <item value="{@link RowMapper} implementation that creates a {@code java.util.Map}&#10; * for each row, representing all columns as key-value pairs: one&#10; * entry for each column, with the column name as key.&#10; *&#10; * &lt;p&gt;The Map implementation to use and the key to use for each column&#10; * in the column Map can be customized through overriding&#10; * {@link #createColumnMap} and {@link #getColumnKey}, respectively.&#10; *&#10; * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; By default, ColumnMapRowMapper will try to build a linked Map&#10; * with case-insensitive keys, to preserve column order as well as allow any&#10; * casing to be used for column names. This requires Commons Collections on the&#10; * classpath (which will be autodetected). Else, the fallback is a standard linked&#10; * HashMap, which will still preserve column order but requires the application&#10; * to specify the column names in the same casing as exposed by the driver." />
      <item value="to specify the column names in the same casing as exposed by the driver." />
      <item value="substitute Named Parameters" />
      <item value="XML Slide Show" />
      <item value="街道乡镇分布" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="101" />
        <entry key="ENGLISH" value="101" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="HUNGARIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="primaryFontFamily" value="Consolas" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="primaryLanguage" value="ENGLISH" />
      </youdao-translate>
    </option>
  </component>
</application>