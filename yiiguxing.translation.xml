<application>
  <component name="AppStorage">
    <histories>
      <item value="入网" />
      <item value="物流" />
      <item value="相册升级版本" />
      <item value="时间控件" />
      <item value="时间周期" />
      <item value="流动趋势" />
      <item value="来源数量" />
      <item value="人口来源" />
      <item value="流出人口" />
      <item value="疆外去向" />
      <item value="外省来源" />
      <item value="人口去向" />
      <item value="迁徙省份" />
      <item value="地市选项" />
      <item value="外出周期分布" />
      <item value="migrant" />
      <item value="外来人口" />
      <item value="Lettuce" />
      <item value="msisdn" />
      <item value="足迹反馈" />
      <item value="精准" />
      <item value="Set the maximum number of seconds that this executor is supposed to block on shutdown in order to wait for remaining tasks to complete their execution before the rest of the container continues to shut down. This is particularly useful if your remaining tasks are likely to need access to other resources that are also managed by the container. &lt;p&gt;By default, this executor won't wait for the termination of tasks at all. It will either shut down immediately, interrupting ongoing tasks and clearing the remaining task queue - or, if the {@link #setWaitForTasksToCompleteOnShutdown &quot;waitForTasksToCompleteOnShutdown&quot;} flag has been set to {@code true}, it will continue to fully execute all ongoing tasks as well as all remaining tasks in the queue, in parallel to the rest of the container shutting down. &lt;p&gt;In either case, if you specify an await-termination period using this property, this executor will wait for the given time (max) for the termination of tasks. As a rule of thumb, specify a significantly higher timeout here if you set &quot;waitForTasksToCompleteOnShutdown&quot; to {@code true} at the same time, since all remaining tasks in the queue will still get executed - in contrast to the default shutdown behavior where it's just about waiting for currently executing tasks that aren't reacting to thread interruption. @see java.util.concurrent.ExecutorService#shutdown() @see java.util.concurrent.ExecutorService#awaitTermination " />
      <item value="shutdown" />
      <item value="/**&#10;&#9; * Set the maximum number of seconds that this executor is supposed to block&#10;&#9; * on shutdown in order to wait for remaining tasks to complete their execution&#10;&#9; * before the rest of the container continues to shut down. This is particularly&#10;&#9; * useful if your remaining tasks are likely to need access to other resources&#10;&#9; * that are also managed by the container.&#10;&#9; * &lt;p&gt;By default, this executor won't wait for the termination of tasks at all.&#10;&#9; * It will either shut down immediately, interrupting ongoing tasks and clearing&#10;&#9; * the remaining task queue - or, if the&#10;&#9; * {@link #setWaitForTasksToCompleteOnShutdown &quot;waitForTasksToCompleteOnShutdown&quot;}&#10;&#9; * flag has been set to {@code true}, it will continue to fully execute all&#10;&#9; * ongoing tasks as well as all remaining tasks in the queue, in parallel to&#10;&#9; * the rest of the container shutting down.&#10;&#9; * &lt;p&gt;In either case, if you specify an await-termination period using this property,&#10;&#9; * this executor will wait for the given time (max) for the termination of tasks.&#10;&#9; * As a rule of thumb, specify a significantly higher timeout here if you set&#10;&#9; * &quot;waitForTasksToCompleteOnShutdown&quot; to {@code true} at the same time,&#10;&#9; * since all remaining tasks in the queue will still get executed - in contrast&#10;&#9; * to the default shutdown behavior where it's just about waiting for currently&#10;&#9; * executing tasks that aren't reacting to thread interruption.&#10;&#9; * @see java.util.concurrent.ExecutorService#shutdown()&#10;&#9; * @see java.util.concurrent.ExecutorService#awaitTermination&#10;&#9; */" />
      <item value="Set the ScheduledExecutorService's pool size." />
      <item value="市内" />
      <item value="点击反馈" />
      <item value="有效时间" />
      <item value="短信" />
      <item value="Malus Spectabilis" />
      <item value="单元测试" />
      <item value="hamcrest" />
      <item value="harmcrest" />
      <item value="terminology" />
      <item value="Executes the given action object within a connection that can be exposed or not. Additionally, the connection can&#10;&#9; * be pipelined. Note the results of the pipeline are discarded (making it suitable for write-only scenarios)." />
      <item value="xecutes the given action object within a connection, which can be exposed or not." />
      <item value="雪碧" />
      <item value="institute" />
      <item value="学院" />
      <item value="学系" />
      <item value="学级" />
      <item value="学科" />
      <item value="专业" />
      <item value="exclusive" />
      <item value="The following code shows examples using var:" />
      <item value="Try-with-resources variable" />
      <item value="Index variables declared in traditional for loops" />
      <item value="Enhanced for-loop indexes" />
      <item value="Local variable declarations with initializers" />
      <item value="var can be used for the following types of variables:" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="284" />
        <entry key="ENGLISH" value="284" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="2" />
        <entry key="ROMANIAN" value="2" />
        <entry key="BENGALI" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="HUNGARIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="primaryFontFamily" value="Consolas" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="primaryLanguage" value="ENGLISH" />
      </youdao-translate>
    </option>
  </component>
</application>