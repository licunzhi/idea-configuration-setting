<application>
  <component name="AppStorage">
    <histories>
      <item value="Insertion sort on smallest arrays" />
      <item value="To be removed in a future release." />
      <item value="used in preference to mergesort." />
      <item value="Tuning parameter: list size at or below which insertion sort will be" />
      <item value="legacy Merge Sort" />
      <item value="legacy" />
      <item value="Navigable" />
      <item value="Sorted Map" />
      <item value="comparisons" />
      <item value="consistent" />
      <item value="analogue" />
      <item value="segment" />
      <item value="creation" />
      <item value="evict" />
      <item value="/**&#10;     * The bin count threshold for untreeifying a (split) bin during a&#10;     * resize operation. Should be less than TREEIFY_THRESHOLD, and at&#10;     * most 6 to mesh with shrinkage detection under removal.&#10;     */" />
      <item value="The bin count threshold for using a tree rather than list for a&#10;     * bin.  Bins are converted to trees when adding an element to a&#10;     * bin with at least this many nodes. The value must be greater&#10;     * than 2 and should be at least 8 to mesh with assumptions in&#10;     * tree removal about conversion back to plain bins upon&#10;     * shrinkage." />
      <item value="Tree bins (i.e., bins whose elements are all TreeNodes) are      * ordered primarily by hashCode, but in the case of ties, if two      * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,      * type then their compareTo method is used for ordering. (We      * conservatively check generic types via reflection to validate      * this -- see method comparableClassFor).  The added complexity      * of tree bins is worthwhile in providing worst-case O(log n)      * operations when keys either have distinct hashes or are      * orderable, Thus, performance degrades gracefully under      * accidental or malicious usages in which hashCode() methods      * return values that are poorly distributed, as well as those in      * which many keys share a hashCode, so long as they are also      * Comparable. (If neither of these apply, we may waste about a      * factor of two in time and space compared to taking no      * precautions. But the only known cases stem from poor user      * programming practices that are already so slow that this makes      * little difference.)" />
      <item value="Tree bins (i.e., bins whose elements are all TreeNodes) are&#10;     * ordered primarily by hashCode, but in the case of ties, if two&#10;     * elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;,&#10;     * type then their compareTo method is used for ordering. (We&#10;     * conservatively check generic types via reflection to validate&#10;     * this -- see method comparableClassFor).  The added complexity&#10;     * of tree bins is worthwhile in providing worst-case O(log n)&#10;     * operations when keys either have distinct hashes or are&#10;     * orderable, Thus, performance degrades gracefully under&#10;     * accidental or malicious usages in which hashCode() methods&#10;     * return values that are poorly distributed, as well as those in&#10;     * which many keys share a hashCode, so long as they are also&#10;     * Comparable. (If neither of these apply, we may waste about a&#10;     * factor of two in time and space compared to taking no&#10;     * precautions. But the only known cases stem from poor user&#10;     * programming practices that are already so slow that this makes&#10;     * little difference.)" />
      <item value="This map usually acts as a binned (bucketed) hash table, but      * when bins get too large, they are transformed into bins of      * TreeNodes, each structured similarly to those in      * java.util.TreeMap. Most methods try to use normal bins, but      * relay to TreeNode methods when applicable (simply by checking      * instanceof a node).  Bins of TreeNodes may be traversed and      * used like any others, but additionally support faster lookup      * when overpopulated. However, since the vast majority of bins in      * normal use are not overpopulated, checking for existence of      * tree bins may be delayed in the course of table methods." />
      <item value="This map usually acts as a binned (bucketed) hash table, but&#10;     * when bins get too large, they are transformed into bins of&#10;     * TreeNodes, each structured similarly to those in&#10;     * java.util.TreeMap. Most methods try to use normal bins, but&#10;     * relay to TreeNode methods when applicable (simply by checking&#10;     * instanceof a node).  Bins of TreeNodes may be traversed and&#10;     * used like any others, but additionally support faster lookup&#10;     * when overpopulated. However, since the vast majority of bins in&#10;     * normal use are not overpopulated, checking for existence of&#10;     * tree bins may be delayed in the course of table methods." />
      <item value="overpopulated" />
      <item value="lookup" />
      <item value="applicable" />
      <item value="each structured similarly to those in&#10;     * java.util.TreeMap." />
      <item value="structured" />
      <item value="bins" />
      <item value="This map usually acts as a binned (bucketed) hash table" />
      <item value="Implementation notes." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="25" />
        <entry key="ENGLISH" value="26" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="primaryFontFamily" value="Consolas" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="primaryLanguage" value="ENGLISH" />
      </youdao-translate>
    </option>
  </component>
</application>