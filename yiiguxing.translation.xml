<application>
  <component name="AppStorage">
    <histories>
      <item value="An enumeration of possible types of web application." />
      <item value="Configures component scanning directives for use with @{@link Configuration} classes.&#10; * Provides support parallel with Spring XML's {@code &lt;context:component-scan&gt;} element.&#10; *&#10; * &lt;p&gt;Either {@link #basePackageClasses} or {@link #basePackages} (or its alias&#10; * {@link #value}) may be specified to define specific packages to scan. If specific&#10; * packages are not defined, scanning will occur from the package of the&#10; * class that declares this annotation.&#10; *&#10; * &lt;p&gt;Note that the {@code &lt;context:component-scan&gt;} element has an&#10; * {@code annotation-config} attribute; however, this annotation does not. This is because&#10; * in almost all cases when using {@code @ComponentScan}, default annotation config&#10; * processing (e.g. processing {@code @Autowired} and friends) is assumed. Furthermore,&#10; * when using {@link AnnotationConfigApplicationContext}, annotation config processors are&#10; * always registered, meaning that any attempt to disable them at the&#10; * {@code @ComponentScan} level would be ignored." />
      <item value="Container annotation that aggregates several ComponentScan annotations. Can be used natively, declaring several nested ComponentScan annotations. Can also be used in conjunction with Java 8's support for repeatable annotations, where ComponentScan can simply be declared several times on the same method, implicitly generating this container annotation." />
      <item value="Container annotation that aggregates several ComponentScan annotations.&#10;Can be used natively, declaring several nested ComponentScan annotations. Can also be used in conjunction with Java 8's support for repeatable annotations, where ComponentScan can simply be declared several times on the same method, implicitly generating this container annotation." />
      <item value="Indicates one or more @Configuration classes to import. Provides functionality equivalent to the &lt;import/&gt; element in Spring XML. Allows for importing @Configuration classes, ImportSelector and ImportBeanDefinitionRegistrar implementations, as well as regular component classes (as of 4.2; analogous to AnnotationConfigApplicationContext.register). @Bean definitions declared in imported @Configuration classes should be accessed by using @Autowired injection. Either the bean itself can be autowired, or the configuration class instance declaring the bean can be autowired. The latter approach allows for explicit, IDE-friendly navigation between @Configuration class methods. May be declared at the class level or as a meta-annotation. If XML or other non-@Configuration bean definition resources need to be imported, use the @ImportResource annotation instead." />
      <item value="Indicates one or more @Configuration classes to import.&#10;Provides functionality equivalent to the &lt;import/&gt; element in Spring XML. Allows for importing @Configuration classes, ImportSelector and ImportBeanDefinitionRegistrar implementations, as well as regular component classes (as of 4.2; analogous to AnnotationConfigApplicationContext.register).&#10;@Bean definitions declared in imported @Configuration classes should be accessed by using @Autowired injection. Either the bean itself can be autowired, or the configuration class instance declaring the bean can be autowired. The latter approach allows for explicit, IDE-friendly navigation between @Configuration class methods.&#10;May be declared at the class level or as a meta-annotation.&#10;If XML or other non-@Configuration bean definition resources need to be imported, use the @ImportResource annotation instead." />
      <item value="Auto-configuration tries to be as intelligent as possible and will back-away as you define more of your own configuration. You can always manually exclude() any configuration that you never want to apply (use excludeName() if you don't have access to them). You can also exclude them via the spring.autoconfigure.exclude property. Auto-configuration is always applied after user-defined beans have been registered. The package of the class that is annotated with @EnableAutoConfiguration, usually via @SpringBootApplication, has specific significance and is often used as a 'default'. For example, it will be used when scanning for @Entity classes. It is generally recommended that you place @EnableAutoConfiguration (if you're not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched. Auto-configuration classes are regular Spring Configuration beans. They are located using the SpringFactoriesLoader mechanism (keyed against this class). Generally auto-configuration beans are @Conditional beans (most often using @ConditionalOnClass and @ConditionalOnMissingBean annotations)." />
      <item value="Auto-configuration tries to be as intelligent as possible and will back-away as you define more of your own configuration. You can always manually exclude() any configuration that you never want to apply (use excludeName() if you don't have access to them). You can also exclude them via the spring.autoconfigure.exclude property. Auto-configuration is always applied after user-defined beans have been registered.&#10;The package of the class that is annotated with @EnableAutoConfiguration, usually via @SpringBootApplication, has specific significance and is often used as a 'default'. For example, it will be used when scanning for @Entity classes. It is generally recommended that you place @EnableAutoConfiguration (if you're not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched.&#10;Auto-configuration classes are regular Spring Configuration beans. They are located using the SpringFactoriesLoader mechanism (keyed against this class). Generally auto-configuration beans are @Conditional beans (most often using @ConditionalOnClass and @ConditionalOnMissingBean annotations)." />
      <item value="Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined. For example, if you have tomcat-embedded.jar on your classpath you are likely to want a TomcatServletWebServerFactory (unless you have defined your own ServletWebServerFactory bean). When using SpringBootApplication, the auto-configuration of the context is automatically enabled and adding this annotation has therefore no additional effect." />
      <item value="Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined. For example, if you have tomcat-embedded.jar on your classpath you are likely to want a TomcatServletWebServerFactory (unless you have defined your own ServletWebServerFactory bean).&#10;When using SpringBootApplication, the auto-configuration of the context is automatically enabled and adding this annotation has therefore no additional effect." />
      <item value="常量" />
      <item value="bread" />
      <item value="地市列表" />
      <item value="advice" />
      <item value="轨迹" />
      <item value="Number of milliseconds to delay before the first execution of a&#10;&#9; * {@link #fixedRate()} or {@link #fixedDelay()} task.&#10;&#9; * @return the initial delay in milliseconds&#10;&#9; * @since 3.2" />
      <item value="* Execute the annotated method with a fixed period in milliseconds between&#10;&#9; * invocations.&#10;&#9; * @return the period in milliseconds" />
      <item value="Execute the annotated method with a fixed period in milliseconds between the&#10;&#9; * end of the last invocation and the start of the next.&#10;&#9; * @return the delay in milliseconds" />
      <item value="过滤外部基站" />
      <item value="画笔" />
      <item value="假中心点" />
      <item value="开始绘制" />
      <item value="color-interpolation" />
      <item value="number" />
      <item value="or (2) 0 for SQL statements that return nothing" />
      <item value="either (1) the row count for SQL Data Manipulation Language (DML) statements" />
      <item value="DML" />
      <item value="Manipulation" />
      <item value="/**&#10;     * Executes the given SQL statement, which returns a single&#10;     * &lt;code&gt;ResultSet&lt;/code&gt; object.&#10;     *&lt;p&gt;&#10;     * &lt;strong&gt;Note:&lt;/strong&gt;This method cannot be called on a&#10;     * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;.&#10;     * @param sql an SQL statement to be sent to the database, typically a&#10;     *        static SQL &lt;code&gt;SELECT&lt;/code&gt; statement&#10;     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object that contains the data produced&#10;     *         by the given query; never &lt;code&gt;null&lt;/code&gt;&#10;     * @exception SQLException if a database access error occurs,&#10;     * this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;, the given&#10;     *            SQL statement produces anything other than a single&#10;     *            &lt;code&gt;ResultSet&lt;/code&gt; object, the method is called on a&#10;     * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;&#10;     * @throws SQLTimeoutException when the driver has determined that the&#10;     * timeout value that was specified by the {@code setQueryTimeout}&#10;     * method has been exceeded and has at least attempted to cancel&#10;     * the currently running {@code Statement}&#10;     */" />
      <item value="/**&#10;     * Executes the given SQL statement, which may return multiple results.&#10;     * In some (uncommon) situations, a single SQL statement may return&#10;     * multiple result sets and/or update counts.  Normally you can ignore&#10;     * this unless you are (1) executing a stored procedure that you know may&#10;     * return multiple results or (2) you are dynamically executing an&#10;     * unknown SQL string.&#10;     * &lt;P&gt;&#10;     * The &lt;code&gt;execute&lt;/code&gt; method executes an SQL statement and indicates the&#10;     * form of the first result.  You must then use the methods&#10;     * &lt;code&gt;getResultSet&lt;/code&gt; or &lt;code&gt;getUpdateCount&lt;/code&gt;&#10;     * to retrieve the result, and &lt;code&gt;getMoreResults&lt;/code&gt; to&#10;     * move to any subsequent result(s).&#10;     * &lt;p&gt;&#10;     *&lt;strong&gt;Note:&lt;/strong&gt;This method cannot be called on a&#10;     * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;.&#10;     * @param sql any SQL statement&#10;     * @return &lt;code&gt;true&lt;/code&gt; if the first result is a &lt;code&gt;ResultSet&lt;/code&gt;&#10;     *         object; &lt;code&gt;false&lt;/code&gt; if it is an update count or there are&#10;     *         no results&#10;     * @exception SQLException if a database access error occurs,&#10;     * this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;,&#10;     * the method is called on a&#10;     * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;&#10;     * @throws SQLTimeoutException when the driver has determined that the&#10;     * timeout value that was specified by the {@code setQueryTimeout}&#10;     * method has been exceeded and has at least attempted to cancel&#10;     * the currently running {@code Statement}&#10;     * @see #getResultSet&#10;     * @see #getUpdateCount&#10;     * @see #getMoreResults" />
      <item value="/**&#10;     * Executes the given SQL statement and signals the driver with the&#10;     * given flag about whether the&#10;     * auto-generated keys produced by this &lt;code&gt;Statement&lt;/code&gt; object&#10;     * should be made available for retrieval.  The driver will ignore the&#10;     * flag if the SQL statement&#10;     * is not an &lt;code&gt;INSERT&lt;/code&gt; statement, or an SQL statement able to return&#10;     * auto-generated keys (the list of such statements is vendor-specific).&#10;     *&lt;p&gt;&#10;     * &lt;strong&gt;Note:&lt;/strong&gt;This method cannot be called on a&#10;     * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;.&#10;     * @param sql an SQL Data Manipulation Language (DML) statement, such as &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or&#10;     * &lt;code&gt;DELETE&lt;/code&gt;; or an SQL statement that returns nothing,&#10;     * such as a DDL statement.&#10;     *&#10;     * @param autoGeneratedKeys a flag indicating whether auto-generated keys&#10;     *        should be made available for retrieval;&#10;     *         one of the following constants:&#10;     *         &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt;&#10;     *         &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;&#10;     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements&#10;     *         or (2) 0 for SQL statements that return nothing&#10;     *&#10;     * @exception SQLException if a database access error occurs,&#10;     *  this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;, the given&#10;     *            SQL statement returns a &lt;code&gt;ResultSet&lt;/code&gt; object,&#10;     *            the given constant is not one of those allowed, the method is called on a&#10;     * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;&#10;     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support&#10;     * this method with a constant of Statement.RETURN_GENERATED_KEYS&#10;     * @throws SQLTimeoutException when the driver has determined that the&#10;     * timeout value that was specified by the {@code setQueryTimeout}&#10;     * method has been exceeded and has at least attempted to cancel&#10;     * the currently running {@code Statement}&#10;     * @since 1.4&#10;     */" />
      <item value="/**      * Executes the given SQL statement and signals the driver with the      * given flag about whether the      * auto-generated keys produced by this &lt;code&gt;Statement&lt;/code&gt; object      * should be made available for retrieval.  The driver will ignore the      * flag if the SQL statement      * is not an &lt;code&gt;INSERT&lt;/code&gt; statement, or an SQL statement able to return      * auto-generated keys (the list of such statements is vendor-specific).      *&lt;p&gt;      * &lt;strong&gt;Note:&lt;/strong&gt;This method cannot be called on a      * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;.      * @param sql an SQL Data Manipulation Language (DML) statement, such as &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or      * &lt;code&gt;DELETE&lt;/code&gt;; or an SQL statement that returns nothing,      * such as a DDL statement.      *      * @param autoGeneratedKeys a flag indicating whether auto-generated keys      *        should be made available for retrieval;      *         one of the following constants:      *         &lt;code&gt;Statement.RETURN_GENERATED_KEYS&lt;/code&gt;      *         &lt;code&gt;Statement.NO_GENERATED_KEYS&lt;/code&gt;      * @return either (1) the row count for SQL Data Manipulation Language (DML) statements      *         or (2) 0 for SQL statements that return nothing      *      * @exception SQLException if a database access error occurs,      *  this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;, the given      *            SQL statement returns a &lt;code&gt;ResultSet&lt;/code&gt; object,      *            the given constant is not one of those allowed, the method is called on a      * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support      * this method with a constant of Statement.RETURN_GENERATED_KEYS      * @throws SQLTimeoutException when the driver has determined that the      * timeout value that was specified by the {@code setQueryTimeout}      * method has been exceeded and has at least attempted to cancel      * the currently running {@code Statement}      * @since 1.4      */" />
      <item value="Executes the given SQL statement, which may be an &lt;code&gt;INSERT&lt;/code&gt;,&#10;     * &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; statement or an&#10;     * SQL statement that returns nothing, such as an SQL DDL statement.&#10;     *&lt;p&gt;&#10;     * &lt;strong&gt;Note:&lt;/strong&gt;This method cannot be called on a&#10;     * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;.&#10;     * @param sql an SQL Data Manipulation Language (DML) statement, such as &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or&#10;     * &lt;code&gt;DELETE&lt;/code&gt;; or an SQL statement that returns nothing,&#10;     * such as a DDL statement.&#10;     *&#10;     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements&#10;     *         or (2) 0 for SQL statements that return nothing&#10;     *&#10;     * @exception SQLException if a database access error occurs,&#10;     * this method is called on a closed &lt;code&gt;Statement&lt;/code&gt;, the given&#10;     * SQL statement produces a &lt;code&gt;ResultSet&lt;/code&gt; object, the method is called on a&#10;     * &lt;code&gt;PreparedStatement&lt;/code&gt; or &lt;code&gt;CallableStatement&lt;/code&gt;&#10;     * @throws SQLTimeoutException when the driver has determined that the&#10;     * timeout value that was specified by the {@code setQueryTimeout}&#10;     * method has been exceeded and has at least attempted to cancel&#10;     * the currently running {@code Statement}" />
      <item value="多边形" />
      <item value="tag TO ESCAPE" />
      <item value="转义" />
      <item value="This method is the equivalent to calling &lt;pre&gt;Encoder.canonicalize(input, strict, strict);" />
      <item value="出行" />
      <item value="行" />
      <item value="出行方式" />
      <item value="where" />
      <item value="试用" />
      <item value="Sets the JWT payload to be a JSON Claims instance populated by the specified name/value pairs.  If you do not&#10;     * want the JWT body to be JSON and instead want it to be a plaintext string, use the {@link #setPayload(String)}&#10;     * method instead." />
      <item value="method instead." />
      <item value="Bearer" />
      <item value="权限" />
      <item value="审核评估" />
      <item value="套餐名字" />
      <item value="话单" />
      <item value="免单计数" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="133" />
        <entry key="ENGLISH" value="134" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="HUNGARIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="primaryFontFamily" value="Consolas" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="primaryLanguage" value="ENGLISH" />
      </youdao-translate>
    </option>
  </component>
</application>